//! This module provides a safe Rust interface to the libSBML UnitDefinition class.
//!
//! The UnitDefinition class represents a unit definition in an SBML model.
//! It can represent a unit, a unit system, or any other entity that can be used to define the units of a model.
//! Each unit definition can have properties like name, kind, and exponent.
//!
//! This wrapper provides safe access to the underlying C++ libSBML UnitDefinition class while
//! maintaining Rust's safety guarantees through the use of RefCell and Pin.

use std::{cell::RefCell, pin::Pin, rc::Rc};

use cxx::let_cxx_string;

use crate::{
    inner,
    model::Model,
    pin_ptr,
    sbmlcxx::{self},
    sbo_term,
    traits::fromptr::FromPtr,
    unit::{Unit, UnitBuilder, UnitKind},
    upcast_annotation,
};

/// A safe wrapper around the libSBML UnitDefinition class.
///
/// This struct maintains a reference to the underlying C++ UnitDefinition object
/// through a RefCell and Pin to ensure memory safety while allowing interior mutability.
pub struct UnitDefinition<'a> {
    inner: RefCell<Pin<&'a mut sbmlcxx::UnitDefinition>>,
    units: RefCell<Vec<Rc<Unit<'a>>>>,
}

// Set the inner trait for the UnitDefinition struct
inner!(sbmlcxx::UnitDefinition, UnitDefinition<'a>);

// Set the annotation trait for the UnitDefinition struct
upcast_annotation!(UnitDefinition<'a>, sbmlcxx::UnitDefinition, sbmlcxx::SBase);

impl<'a> UnitDefinition<'a> {
    /// Creates a new UnitDefinition instance within the given Model.
    ///
    /// # Arguments
    /// * `model` - The parent Model that will contain this unit definition
    /// * `id` - The identifier for this unit definition
    /// * `name` - The name of this unit definition
    ///
    /// # Returns
    /// A new UnitDefinition instance
    pub fn new(model: &Model<'a>, id: &str, name: &str) -> Self {
        let unit_definition_ptr = model.inner().borrow_mut().as_mut().createUnitDefinition();
        let mut unit_definition = pin_ptr!(unit_definition_ptr, sbmlcxx::UnitDefinition);

        let_cxx_string!(id = id);
        unit_definition.as_mut().setId(&id);

        let_cxx_string!(name = name);
        unit_definition.as_mut().setName(&name);

        Self {
            inner: RefCell::new(unit_definition),
            units: RefCell::new(Vec::new()),
        }
    }

    pub fn name(&self) -> String {
        self.inner.borrow().getName().to_str().unwrap().to_string()
    }

    pub fn set_name(&self, name: &str) {
        let_cxx_string!(name = name);
        self.inner.borrow_mut().as_mut().setName(&name);
    }

    pub fn id(&self) -> String {
        self.inner.borrow().getId().to_str().unwrap().to_string()
    }

    pub fn set_id(&self, id: &str) {
        let_cxx_string!(id = id);
        self.inner.borrow_mut().as_mut().setId(&id);
    }

    /// Creates a new Unit within this UnitDefinition.
    ///
    /// # Returns
    /// A new Unit instance
    pub fn create_unit(&self, kind: UnitKind) -> Rc<Unit<'a>> {
        let unit = Rc::new(Unit::new(self, kind));
        self.units.borrow_mut().push(Rc::clone(&unit));
        unit
    }

    /// Creates a new UnitBuilder for this UnitDefinition.
    ///
    /// # Returns
    /// A new UnitBuilder instance
    pub fn build_unit(&self, kind: UnitKind) -> UnitBuilder<'a> {
        UnitBuilder::new(self, kind)
    }

    /// Returns a vector of all units in the unit definition.
    ///
    /// # Returns
    /// A vector of all units in the unit definition
    pub fn units(&self) -> Vec<Rc<Unit<'a>>> {
        self.units.borrow().to_vec()
    }

    /// Returns a unit from the unit definition by kind.
    ///
    /// # Returns
    /// A unit from the unit definition by kind
    pub fn get_unit(&self, kind: UnitKind) -> Option<Rc<Unit<'a>>> {
        self.units
            .borrow()
            .iter()
            .find(|unit| unit.kind() == kind)
            .map(|unit| Rc::clone(unit))
    }

    // SBO Term Methods generated by the `sbo_term` macro
    sbo_term!(sbmlcxx::UnitDefinition, sbmlcxx::SBase);
}

impl FromPtr<sbmlcxx::UnitDefinition> for UnitDefinition<'_> {
    /// Creates a new UnitDefinition instance from a unique pointer to a libSBML UnitDefinition.
    ///
    /// This method is primarily used internally by the Model class to create
    /// UnitDefinition instances from libSBML UnitDefinition pointers.
    ///
    /// # Arguments
    /// * `ptr` - A unique pointer to a libSBML UnitDefinition
    ///
    /// # Returns
    /// A new UnitDefinition instance
    fn from_ptr(ptr: *mut sbmlcxx::UnitDefinition) -> Self {
        let unit_definition = pin_ptr!(ptr, sbmlcxx::UnitDefinition);
        Self {
            inner: RefCell::new(unit_definition),
            units: RefCell::new(Vec::new()),
        }
    }
}
/// A builder for constructing UnitDefinition instances with a fluent interface.
///
/// This struct provides a builder pattern interface for creating and configuring
/// UnitDefinition objects. It allows chaining method calls to set various properties
/// before finally constructing the UnitDefinition.
pub struct UnitDefinitionBuilder<'a> {
    unit_definition: Rc<UnitDefinition<'a>>,
}

impl<'a> UnitDefinitionBuilder<'a> {
    /// Creates a new UnitDefinitionBuilder instance.
    ///
    /// # Arguments
    /// * `model` - The parent Model that will contain this unit definition
    /// * `id` - The identifier for this unit definition
    /// * `name` - The name for this unit definition
    ///
    /// # Returns
    /// A new UnitDefinitionBuilder instance
    pub fn new(model: &Model<'a>, id: &str, name: &str) -> Self {
        let unit_definition = model.create_unit_definition(id, name);
        Self { unit_definition }
    }

    /// Adds a unit to this unit definition with the specified properties.
    ///
    /// # Arguments
    /// * `kind` - The kind of unit to add (e.g. metre, second, etc)
    /// * `exponent` - Optional exponent for the unit (defaults to 1)
    /// * `scale` - Optional scale factor for the unit (defaults to 1)
    /// * `multiplier` - Optional multiplier for the unit (defaults to 1.0)
    /// * `offset` - Optional offset for the unit (defaults to 0.0)
    ///
    /// # Returns
    /// The builder instance for method chaining
    pub fn unit(
        self,
        kind: UnitKind,
        exponent: Option<i32>,
        scale: Option<i32>,
        multiplier: Option<f64>,
        offset: Option<f64>,
    ) -> Self {
        let exponent = exponent.unwrap_or(1);
        let scale = scale.unwrap_or(1);
        let multiplier = multiplier.unwrap_or(1.0);
        let offset = offset.unwrap_or(0.0);

        let unit = self.unit_definition.create_unit(kind);
        unit.set_exponent(exponent);
        unit.set_scale(scale);
        unit.set_multiplier(multiplier);
        unit.set_offset(offset);
        self
    }

    /// Builds and returns the configured UnitDefinition instance.
    ///
    /// # Returns
    /// The constructed UnitDefinition instance wrapped in an Rc
    pub fn build(self) -> Rc<UnitDefinition<'a>> {
        self.unit_definition
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::prelude::*;

    #[test]
    fn test_unit_definition_new() {
        let doc = SBMLDocument::new(3, 2);
        let model = Model::new(&doc, "test");
        let unit_definition = UnitDefinition::new(&model, "test", "test");

        unit_definition.set_name("test2");
        unit_definition.set_id("test2");

        assert_eq!(unit_definition.id(), "test2");
        assert_eq!(unit_definition.name(), "test2");
    }

    #[test]
    fn test_unit_definition_builder() {
        let doc = SBMLDocument::new(3, 2);
        let model = Model::new(&doc, "test");
        let unit_definition = UnitDefinitionBuilder::new(&model, "test", "test").build();
        assert_eq!(unit_definition.id(), "test");
    }

    #[test]
    fn test_unit_definition_add_unit() {
        let doc = SBMLDocument::new(3, 2);
        let model = Model::new(&doc, "test");
        let unit_definition = UnitDefinitionBuilder::new(&model, "test", "test").build();
        let unit = unit_definition.create_unit(UnitKind::Metre);
        assert_eq!(unit.kind(), UnitKind::Metre);
    }

    #[test]
    fn test_build_unit() {
        let doc = SBMLDocument::default();
        let model = Model::new(&doc, "test");
        let unit_definition = model.create_unit_definition("test", "test");
        let unit = unit_definition.build_unit(UnitKind::Metre).build();
        assert_eq!(unit.kind(), UnitKind::Metre);
    }

    #[test]
    fn test_unit_definition_builder_units() {
        let doc = SBMLDocument::new(3, 2);
        let model = Model::new(&doc, "test");
        let unit_definition = UnitDefinitionBuilder::new(&model, "test", "test")
            .unit(UnitKind::Metre, Some(1), Some(0), Some(1.0), Some(0.0))
            .unit(UnitKind::Second, Some(1), Some(0), Some(1.0), Some(0.0))
            .build();
        let units = unit_definition.units();
        assert_eq!(units.len(), 2);
        assert_eq!(units[0].kind(), UnitKind::Metre);
        assert_eq!(units[1].kind(), UnitKind::Second);
    }

    #[test]
    fn test_unit_definition_get_unit() {
        let doc = SBMLDocument::new(3, 2);
        let model = Model::new(&doc, "test");
        let unit_definition = model.create_unit_definition("test", "test");
        let unit = unit_definition.create_unit(UnitKind::Metre);
        unit.set_scale(2);

        let unit = unit_definition.get_unit(UnitKind::Metre);
        assert_eq!(unit.unwrap().scale(), 2);
    }

    #[test]
    fn test_unit_definition_get_unit_not_found() {
        let doc = SBMLDocument::new(3, 2);
        let model = Model::new(&doc, "test");
        let unit_definition = model.create_unit_definition("test", "test");
        let unit = unit_definition.get_unit(UnitKind::Metre);
        assert!(unit.is_none());
    }

    #[test]
    fn test_unit_definition_annotation() {
        let doc = SBMLDocument::default();
        let model = Model::new(&doc, "test");
        let unit_definition = model.create_unit_definition("test", "test");
        unit_definition
            .set_annotation("<test>test</test>")
            .expect("Failed to set annotation");
        assert_eq!(
            unit_definition
                .get_annotation()
                .replace("\n", "")
                .replace(" ", ""),
            "<annotation><test>test</test></annotation>"
        );
    }

    #[test]
    fn test_unit_definition_annotation_serde() {
        #[derive(Serialize, Deserialize)]
        struct TestAnnotation {
            test: String,
        }

        let annotation = TestAnnotation {
            test: "test".to_string(),
        };
        let doc = SBMLDocument::default();
        let model = Model::new(&doc, "test");
        let unit_definition = model.create_unit_definition("test", "test");
        unit_definition
            .set_annotation_serde(&annotation)
            .expect("Failed to set annotation");
        let annotation = unit_definition
            .get_annotation_serde::<TestAnnotation>()
            .expect("Failed to get annotation");
        assert_eq!(annotation.test, "test");
    }
}

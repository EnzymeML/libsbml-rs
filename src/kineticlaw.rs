//! This module provides a safe Rust interface to the libSBML KineticLaw class.
//!
//! The KineticLaw class represents a mathematical expression that defines the rate
//! at which a reaction occurs in an SBML model. It encapsulates the quantitative
//! aspects of reaction kinetics, such as mass action, Michaelis-Menten, or other
//! custom rate laws.
//!
//! KineticLaws can include:
//! - Mathematical formulas (e.g., "k * S1 * S2")
//! - Local parameters specific to the reaction
//! - References to global parameters and species
//! - Units of measurement for the rate
//!
//! This wrapper provides safe access to the underlying C++ libSBML KineticLaw class while
//! maintaining Rust's safety guarantees through the use of RefCell and Pin.

use std::{cell::RefCell, pin::Pin};

use cxx::let_cxx_string;

use crate::{
    clone, inner, pin_ptr, prelude::Reaction, sbmlcxx, sbo_term, traits::fromptr::FromPtr,
    upcast_annotation,
};

/// A safe wrapper around the libSBML KineticLaw class.
///
/// This struct maintains a reference to the underlying C++ KineticLaw object
/// through a RefCell and Pin to ensure memory safety while allowing interior mutability.
///
/// KineticLaw objects define the mathematical rules that govern reaction rates in
/// systems biology models. They can range from simple mass action kinetics to complex
/// enzymatic rate laws.
pub struct KineticLaw<'a> {
    inner: RefCell<Pin<&'a mut sbmlcxx::KineticLaw>>,
}

// Set the inner trait for the KineticLaw struct
inner!(sbmlcxx::KineticLaw, KineticLaw<'a>);

// Set the annotation trait for the KineticLaw struct
upcast_annotation!(KineticLaw<'a>, sbmlcxx::KineticLaw, sbmlcxx::SBase);

// Implement the Clone trait for the KineticLaw struct
clone!(KineticLaw<'a>, sbmlcxx::KineticLaw);

impl<'a> KineticLaw<'a> {
    /// Creates a new KineticLaw instance for the given Reaction.
    ///
    /// This method creates a new kinetic law with the specified mathematical formula
    /// and associates it with the provided reaction. The formula defines how the
    /// reaction rate is calculated based on species concentrations, parameters, and
    /// other model elements.
    ///
    /// # Arguments
    /// * `reaction` - The parent Reaction that will contain this kinetic law
    /// * `formula` - The mathematical formula for this kinetic law (e.g., "k1 * S1")
    ///
    /// # Returns
    /// A new KineticLaw instance initialized with the given formula and added to the reaction
    pub fn new(reaction: &Reaction<'a>, formula: &str) -> Self {
        let kinetic_law_ptr = reaction.inner().borrow_mut().as_mut().createKineticLaw();
        let mut kinetic_law = pin_ptr!(kinetic_law_ptr, sbmlcxx::KineticLaw);

        let_cxx_string!(formula = formula);
        kinetic_law.as_mut().setFormula(&formula);

        Self {
            inner: RefCell::new(kinetic_law),
        }
    }

    /// Gets the mathematical formula of the kinetic law.
    ///
    /// This method retrieves the current mathematical expression that defines
    /// the reaction rate. The formula is returned as a string representation.
    ///
    /// # Returns
    /// The formula of the kinetic law as a string.
    pub fn formula(&self) -> String {
        self.inner().borrow().getFormula().to_string()
    }

    /// Sets the mathematical formula of the kinetic law.
    ///
    /// This method updates the mathematical expression that defines the reaction rate.
    /// The formula should be a valid mathematical expression that can reference species,
    /// parameters, and other model elements.
    ///
    /// # Arguments
    /// * `formula` - The new mathematical formula to set for the kinetic law
    pub fn set_formula(&self, formula: &str) {
        let_cxx_string!(formula = formula);
        self.inner().borrow_mut().as_mut().setFormula(&formula);
    }

    // SBO Term Methods generated by the `sbo_term` macro
    sbo_term!(sbmlcxx::KineticLaw, sbmlcxx::SBase);
}

impl FromPtr<sbmlcxx::KineticLaw> for KineticLaw<'_> {
    /// Creates a KineticLaw instance from a raw pointer to a libSBML KineticLaw.
    ///
    /// This implementation allows converting from a raw C++ pointer to a safe Rust wrapper.
    /// It's primarily used internally by the library.
    ///
    /// # Arguments
    /// * `ptr` - Raw pointer to a libSBML KineticLaw object
    ///
    /// # Returns
    /// A new KineticLaw instance wrapping the provided pointer
    fn from_ptr(ptr: *mut sbmlcxx::KineticLaw) -> Self {
        let kinetic_law = pin_ptr!(ptr, sbmlcxx::KineticLaw);
        Self {
            inner: RefCell::new(kinetic_law),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use crate::{model::Model, reaction::Reaction, SBMLDocument};
    use serde::{Deserialize, Serialize};

    #[test]
    fn test_kinetic_law_new() {
        let doc = SBMLDocument::new(3, 2);
        let model = Model::new(&doc, "test");
        let reaction = Reaction::new(&model, "r1");
        let kinetic_law = KineticLaw::new(&reaction, "k1 * S1");
        assert_eq!(kinetic_law.formula(), "k1 * S1");
    }

    #[test]
    fn test_set_formula() {
        let doc = SBMLDocument::new(3, 2);
        let model = Model::new(&doc, "test");
        let reaction = Reaction::new(&model, "r1");
        let kinetic_law = KineticLaw::new(&reaction, "k1 * S1");
        kinetic_law.set_formula("k2 * S2");
        assert_eq!(kinetic_law.formula(), "k2 * S2");
    }

    #[test]
    fn test_annotation() {
        let doc = SBMLDocument::new(3, 2);
        let model = Model::new(&doc, "test");
        let reaction = Reaction::new(&model, "r1");
        let kinetic_law = KineticLaw::new(&reaction, "k1 * S1");
        kinetic_law
            .set_annotation("<test>test</test>")
            .expect("Failed to set annotation");
        assert_eq!(
            kinetic_law
                .get_annotation()
                .replace("\n", "")
                .replace(' ', ""),
            "<annotation><test>test</test></annotation>"
        );
    }

    #[test]
    fn test_annotation_serde() {
        #[derive(Serialize, Deserialize)]
        struct TestAnnotation {
            test: String,
        }

        let doc = SBMLDocument::new(3, 2);
        let model = Model::new(&doc, "test");
        let reaction = Reaction::new(&model, "r1");
        let kinetic_law = KineticLaw::new(&reaction, "k1 * S1");

        kinetic_law
            .set_annotation_serde(&TestAnnotation {
                test: "test".to_string(),
            })
            .expect("Failed to set annotation");

        let annotation = kinetic_law
            .get_annotation_serde::<TestAnnotation>()
            .expect("Failed to deserialize annotation");

        assert_eq!(annotation.test, "test");
    }

    #[test]
    fn test_sbo_term() {
        let doc = SBMLDocument::new(3, 2);
        let model = Model::new(&doc, "test");
        let reaction = Reaction::new(&model, "r1");
        let kinetic_law = KineticLaw::new(&reaction, "k1 * S1");

        kinetic_law.set_sbo_term("SBO:0000001");
        assert_eq!(kinetic_law.sbo_term_id(), "SBO:0000001");
        assert!(kinetic_law.sbo_term_url().contains("SBO:0000001"));
    }

    #[test]
    fn test_clone() {
        let doc = SBMLDocument::new(3, 2);
        let model = Model::new(&doc, "test");
        let reaction = Reaction::new(&model, "r1");
        let kinetic_law = KineticLaw::new(&reaction, "k1 * S1");

        let cloned_kinetic_law = kinetic_law.clone();
        assert_eq!(kinetic_law.formula(), cloned_kinetic_law.formula());

        // Modify the clone and verify it doesn't affect the original
        cloned_kinetic_law.set_formula("k2 * S2");
        assert_eq!(kinetic_law.formula(), "k1 * S1");
        assert_eq!(cloned_kinetic_law.formula(), "k2 * S2");
    }
}

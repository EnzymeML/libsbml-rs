//! This module provides a safe Rust interface to the libSBML ModifierSpeciesReference class.
//!
//! The ModifierSpeciesReference class represents a reference to a species in an SBML model.
//! It can represent references to species, such as reactants, products, or other biochemical
//! processes. Each species reference can have properties like stoichiometry, and compartment.
//!
//! This wrapper provides safe access to the underlying C++ libSBML ModifierSpeciesReference class while
//! maintaining Rust's safety guarantees through the use of RefCell and Pin.

use std::{cell::RefCell, pin::Pin};

use crate::{
    inner, pin_ptr, prelude::IntoId, reaction::Reaction, sbmlcxx, sbo_term, upcast,
    upcast_annotation, upcast_pin,
};
use cxx::let_cxx_string;

/// A safe wrapper around the libSBML SpeciesReference class.
///
/// This struct maintains a reference to the underlying C++ SpeciesReference object
/// through a RefCell and Pin to ensure memory safety while allowing interior mutability.
pub struct ModifierSpeciesReference<'a> {
    inner: RefCell<Pin<&'a mut sbmlcxx::ModifierSpeciesReference>>,
}

// Set the inner trait for the ModifierSpeciesReference struct
inner!(
    sbmlcxx::ModifierSpeciesReference,
    ModifierSpeciesReference<'a>
);

// Set the annotation trait for the ModifierSpeciesReference struct
upcast_annotation!(
    ModifierSpeciesReference<'a>,
    sbmlcxx::ModifierSpeciesReference,
    sbmlcxx::SBase
);

impl<'a> ModifierSpeciesReference<'a> {
    /// Creates a new SimpleSpeciesReference instance within the given Reaction.
    ///
    /// # Arguments
    /// * `reaction` - The parent Reaction that will contain this species reference
    /// * `sid` - The identifier for this species reference
    ///
    /// # Returns
    /// A new SpeciesReference instance
    pub(crate) fn new(reaction: &Reaction<'a>, sid: &str) -> Self {
        let modifier_reference_ptr = reaction.inner().borrow_mut().as_mut().createModifier();
        let mut modifier_reference =
            pin_ptr!(modifier_reference_ptr, sbmlcxx::ModifierSpeciesReference);

        // We need to fall back to custom wrappers for the species reference
        // because autocxx does not support setting the species reference's species
        // most likely because it is a virtual base class.
        let_cxx_string!(sid = sid);
        let simple_spec_ref = upcast_pin!(
            modifier_reference,
            sbmlcxx::ModifierSpeciesReference,
            sbmlcxx::SimpleSpeciesReference
        );
        simple_spec_ref.setSpecies(&sid);

        Self {
            inner: RefCell::new(modifier_reference),
        }
    }

    /// Returns the species of the species reference.
    ///
    /// # Returns
    /// A string containing the species of the species reference.
    pub fn species(&self) -> String {
        let species = upcast!(
            self,
            sbmlcxx::ModifierSpeciesReference,
            sbmlcxx::SimpleSpeciesReference
        );

        species.getSpecies().to_str().unwrap().to_string()
    }

    /// Sets the species of the species reference.
    ///
    /// # Arguments
    /// * `species` - The species to set
    pub fn set_species(&self, species: &str) {
        let simple_spec_ref = upcast!(
            self,
            sbmlcxx::ModifierSpeciesReference,
            sbmlcxx::SimpleSpeciesReference
        );
        let_cxx_string!(species = species);
        simple_spec_ref.setSpecies(&species);
    }

    // SBO Term Methods generated by the `sbo_term` macro
    sbo_term!(sbmlcxx::ModifierSpeciesReference, sbmlcxx::SBase);
}

/// A builder for constructing ModifierSpeciesReference instances with a fluent API.
///
/// This struct provides a builder pattern interface for creating and configuring
/// ModifierSpeciesReference objects. It allows chaining method calls to set various properties
/// before finally constructing the ModifierSpeciesReference.
pub struct ModifierSpeciesReferenceBuilder<'a> {
    modifier_reference: ModifierSpeciesReference<'a>,
}

impl<'a> ModifierSpeciesReferenceBuilder<'a> {
    /// Creates a new ModifierSpeciesReferenceBuilder instance.
    ///
    /// # Arguments
    /// * `reaction` - The parent Reaction that will contain this species reference
    /// * `sid` - The species identifier for this reference
    ///
    /// # Returns
    /// A new ModifierSpeciesReferenceBuilder instance
    pub fn new(reaction: &Reaction<'a>, sid: impl IntoId<'a>) -> Self {
        let modifier_reference = ModifierSpeciesReference::new(reaction, sid.into_id());
        Self { modifier_reference }
    }

    /// Sets the annotation for this modifier species reference.
    ///
    /// # Arguments
    /// * `annotation` - The annotation string to set
    ///
    /// # Returns
    /// Result containing the builder instance or error
    pub fn annotation(self, annotation: &str) -> Result<Self, SeError> {
        self.modifier_reference
            .set_annotation(annotation)
            .map_err(|e| SeError::Custom(e.to_string()))?;
        Ok(self)
    }

    /// Sets the annotation using a serializable type.
    ///
    /// # Arguments
    /// * `annotation` - The annotation data to serialize and set
    ///
    /// # Returns
    /// Result containing the builder instance or error
    pub fn annotation_serde<T: Serialize>(self, annotation: &T) -> Result<Self, SeError> {
        self.modifier_reference.set_annotation_serde(annotation)?;
        Ok(self)
    }

    /// Builds and returns the configured ModifierSpeciesReference instance.
    ///
    /// # Returns
    /// The constructed SpeciesReference instance
    pub fn build(self) -> ModifierSpeciesReference<'a> {
        self.modifier_reference
    }
}

#[cfg(test)]
mod tests {
    use crate::SBMLDocument;

    use super::*;

    /// Tests creating a new reactant species reference directly
    ///
    /// This test verifies that:
    /// - A species reference can be created with a reaction and species ID
    /// - The species ID is correctly set and retrievable
    #[test]
    fn test_create_species_reference() {
        let doc = SBMLDocument::new(3, 2);
        let model = doc.create_model("test_model");
        let reaction = model.create_reaction("test_reaction");
        let modifier_reference = ModifierSpeciesReference::new(&reaction, "test_species");

        // Check that the species reference is created correctly
        assert_eq!(modifier_reference.species(), "test_species");
    }

    /// Tests the species reference builder pattern
    ///
    /// This test verifies that:
    /// - A species reference can be created using the builder pattern
    /// - Properties like stoichiometry and constant can be set via builder methods
    /// - The built species reference has the correct property values
    #[test]
    fn test_species_reference_builder() {
        let doc = SBMLDocument::new(3, 2);
        let model = doc.create_model("test_model");
        let reaction = model.create_reaction("test_reaction");
        let modifier_reference =
            ModifierSpeciesReferenceBuilder::new(&reaction, "test_species").build();

        assert_eq!(modifier_reference.species(), "test_species");
    }

    /// Tests setting string annotations via the builder
    ///
    /// This test verifies that:
    /// - String annotations can be set using the builder pattern
    /// - The annotation is correctly stored and retrievable
    /// - The annotation is wrapped in proper XML tags
    #[test]
    fn test_species_reference_builder_str_annotation() {
        let doc = SBMLDocument::new(3, 2);
        let model = doc.create_model("test_model");
        let reaction = model.create_reaction("test_reaction");
        let modifier_reference = ModifierSpeciesReferenceBuilder::new(&reaction, "test_species")
            .annotation("<test>test_annotation</test>")
            .unwrap()
            .build();

        assert_eq!(
            modifier_reference
                .get_annotation()
                .replace("\n", "")
                .replace(' ', ""),
            "<annotation><test>test_annotation</test></annotation>"
        );
    }

    /// Tests setting and retrieving serializable annotations via the builder
    ///
    /// This test verifies that:
    /// - Serializable structs can be used as annotations
    /// - The annotation is correctly serialized, stored, and later deserialized
    /// - The deserialized data matches the original input
    #[test]
    fn test_species_reference_builder_serde_annotation() {
        #[derive(Serialize, Deserialize)]
        struct TestAnnotation {
            test: String,
        }

        let doc = SBMLDocument::new(3, 2);
        let model = doc.create_model("test_model");
        let reaction = model.create_reaction("test_reaction");
        let annotation = TestAnnotation {
            test: "test_annotation".to_string(),
        };
        let modifier_reference = ModifierSpeciesReferenceBuilder::new(&reaction, "test_species")
            .annotation_serde(&annotation)
            .unwrap()
            .build();

        // Extract the annotation from the species reference
        let extracted_annotation: TestAnnotation =
            modifier_reference.get_annotation_serde().unwrap();
        assert_eq!(extracted_annotation.test, "test_annotation");
    }
}
